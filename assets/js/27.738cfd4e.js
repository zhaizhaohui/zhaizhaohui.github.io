(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{316:function(a,s,e){"use strict";e.r(s);var t=e(8),r=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"http缓存的有效时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http缓存的有效时间"}},[a._v("#")]),a._v(" HTTP缓存的有效时间")]),a._v(" "),s("p",[a._v("要设置HTTP缓存的有效时间，可以通过在服务器端设置响应头中的相关字段来实现。以下是几种常见的设置HTTP缓存有效时间的方式及对应的字段：")]),a._v(" "),s("h2",{attrs:{id:"_1-使用cache-control-max-age指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用cache-control-max-age指令"}},[a._v("#")]),a._v(" 1. 使用Cache-Control: max-age指令")]),a._v(" "),s("p",[a._v("这是现代HTTP缓存控制中最常用的方式，用于精确指定资源在缓存中可以保存的最长时间（以秒为单位）。")]),a._v(" "),s("p",[a._v("例如，如果你希望某个资源在缓存中保存一小时（3600秒），可以在服务器端发送响应时，在响应头中设置如下：")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("Cache-Control: max-age"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3600")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("当客户端接收到带有这样响应头的资源后，在接下来的3600秒内，如果再次请求该资源，且没有其他特殊情况（如用户强制刷新等），客户端可以直接从缓存中获取该资源，无需再向服务器确认其有效性。")]),a._v(" "),s("h2",{attrs:{id:"_2-使用expires字段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用expires字段"}},[a._v("#")]),a._v(" 2. 使用Expires字段")]),a._v(" "),s("p",[a._v("这是一个相对老式但仍被部分服务器使用的设置缓存有效时间的方式。它指定了一个绝对的时间点，在这个时间点之后，缓存的资源将被认为是过期的。")]),a._v(" "),s("p",[a._v("例如，假设当前时间是2024年11月4日10:00:00，你希望某个资源在两小时后过期，那么可以设置Expires字段如下：")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("Expires: "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2024")]),a._v("-11-04 "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),a._v(":00:00 GMT\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("需要注意的是，Expires字段是基于绝对时间的。")]),a._v(" "),s("p",[a._v("这就存在一个问题：如果客户端的时钟与服务器的时钟不一致，可能会导致缓存判断不准确。例如，客户端时钟快于服务器时钟，可能会提前认为缓存过期而向服务器重新请求资源；反之，客户端时钟慢于服务器时钟，可能会在资源实际上已经过期后，仍从缓存中获取而未向服务器确认。")]),a._v(" "),s("p",[a._v("因此，在现代HTTP应用中，更推荐使用Cache-Control: max-age指令来设置缓存有效时间。")]),a._v(" "),s("h2",{attrs:{id:"_3-结合使用cache-control和last-modified-etag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-结合使用cache-control和last-modified-etag"}},[a._v("#")]),a._v(" 3. 结合使用Cache-Control和Last-Modified/ETag")]),a._v(" "),s("p",[a._v("这种方式可以在一定程度上更灵活地控制缓存有效时间以及验证缓存是否仍然有效。")]),a._v(" "),s("ul",[s("li",[a._v("首先，设置Cache-Control的相关指令，如设置max-age来初步确定缓存的有效时间范围。")]),a._v(" "),s("li",[a._v("然后，同时设置Last-Modified字段（服务器记录资源最后一次修改的时间戳）或ETag字段（服务器为每个资源生成的一个唯一标识符）。")])]),a._v(" "),s("p",[a._v("当客户端再次请求该资源时，可以在请求头中带上上次获取该资源时服务器响应头中给出的Last-Modified时间戳（通过If-Modified-Since字段）或ETag值（通过If-None-Match字段）。服务器收到请求后，根据这些信息来判断资源是否修改过，如果资源未修改，即使缓存时间可能已经接近或超过了最初设置的max-age时间，服务器也可以返回一个特殊的状态码（如304 Not Modified），告知客户端可以继续使用缓存中的资源；如果资源已修改，则会返回完整的资源更新。")]),a._v(" "),s("p",[a._v("例如，服务器端设置如下响应头：")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("Cache-Control: max-age"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3600")]),a._v(" \nLast-Modified: "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2024")]),a._v("-11-04 09:00:00 GMT\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("客户端在下次请求该资源时，会在请求头中带上If-Modified-Since: 2024-11-04 09:00:00 GMT。如果资源自2024-11-04 09:00:00 GMT之后没有修改过，服务器就会返回304 Not Modified，让客户端继续使用缓存中的资源。")])])}),[],!1,null,null,null);s.default=r.exports}}]);