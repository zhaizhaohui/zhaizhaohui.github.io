(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{311:function(t,_,a){"use strict";a.r(_);var r=a(8),s=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http-1-0和2-0区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0和2-0区别"}},[t._v("#")]),t._v(" HTTP 1.0和2.0区别")]),t._v(" "),_("p",[t._v("HTTP 1.0和HTTP 2.0是HTTP协议的不同版本，它们之间存在多方面的区别，以下是详细介绍：")]),t._v(" "),_("h2",{attrs:{id:"_1、性能方面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、性能方面"}},[t._v("#")]),t._v(" 1、性能方面")]),t._v(" "),_("h3",{attrs:{id:"_1-1、连接复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、连接复用"}},[t._v("#")]),t._v(" 1.1、连接复用")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("HTTP 1.0")]),t._v("：每个HTTP请求都需要建立一个新的TCP连接，当浏览器需要请求多个资源（如一个网页中的多个图片、CSS文件、JavaScript文件等）时，就会频繁地创建和关闭TCP连接，这会带来较大的开销，导致性能损耗。例如，一个网页包含10个图片，那么就需要建立10个单独的TCP连接来获取这些图片。")]),t._v(" "),_("li",[_("strong",[t._v("HTTP 2.0")]),t._v("：引入了多路复用（Multiplexing）技术，允许在一个TCP连接上同时发送多个请求和接收多个响应，无需像HTTP 1.0那样为每个请求都建立新的连接。这大大提高了连接的复用率，减少了建立和关闭连接的开销，从而提升了性能。比如，同样对于包含10个图片的网页，在HTTP 2.0下可以通过一个TCP连接同时获取这10个图片。")])]),t._v(" "),_("h3",{attrs:{id:"_1-2、-头部压缩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、-头部压缩"}},[t._v("#")]),t._v(" 1.2、 头部压缩")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("HTTP 1.0")]),t._v("：请求和响应头部信息通常不进行压缩，以明文形式发送。随着网页内容越来越复杂，请求和响应头部可能会变得很长，占用大量的网络带宽，影响传输效率。例如，一些复杂的网页应用可能会有很长的Cookie信息、用户代理信息等在头部传输。")]),t._v(" "),_("li",[_("strong",[t._v("HTTP 2.0")]),t._v("：采用了HPACK头部压缩算法，对请求和响应头部进行压缩后再发送。通过这种方式，可以显著减少头部信息所占用的网络带宽，提高传输效率。据统计，经过HPACK压缩后，头部信息的大小通常能减少到原来的几分之一甚至更小。")])]),t._v(" "),_("h2",{attrs:{id:"_2、数据传输方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、数据传输方式"}},[t._v("#")]),t._v(" 2、数据传输方式")]),t._v(" "),_("h3",{attrs:{id:"_1-二进制分帧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-二进制分帧"}},[t._v("#")]),t._v(" 1. 二进制分帧")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("HTTP 1.0")]),t._v("：数据传输基于文本格式，请求和响应都是以文本形式进行编码和传输的。这种文本格式在解析时相对简单，但效率不高，而且容易出现格式错误等问题。例如，一个HTTP请求可能是这样的：“GET /index.html HTTP/1.0\\r\\nHost: example.com\\r\\n\\r\\n”，其中每一行都是以文本形式呈现的。")]),t._v(" "),_("li",[_("strong",[t._v("HTTP 2.0")]),t._v("：采用了二进制分帧（Binary Framing）技术，将数据分成多个帧（Frame）进行传输，每个帧都是二进制格式的。这种二进制格式的传输更加高效、准确，并且可以更好地支持多路复用等特性。例如，一个HTTP 2.0的请求可能会被分成多个不同类型的帧，如头部帧、数据帧等，分别进行传输和处理。")])]),t._v(" "),_("h2",{attrs:{id:"_3、请求优先级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、请求优先级"}},[t._v("#")]),t._v(" 3、请求优先级")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("HTTP 1.0")]),t._v("：没有明确的请求优先级机制，当浏览器同时发送多个请求时，服务器会按照接收到请求的先后顺序进行处理，无法根据请求的重要性或紧急程度来优先处理某些请求。例如，对于一个网页，可能图片请求和关键的JavaScript脚本请求会同时发送到服务器，但服务器并不能区分它们的优先级，只能依次处理。")]),t._v(" "),_("li",[_("strong",[t._v("HTTP 2.0")]),t._v("：具备请求优先级（Request Priorities）机制，可以为不同的请求设置不同的优先级。服务器在接收到多个请求时，能够根据请求的优先级来安排处理顺序，优先处理高优先级的请求。比如，对于一个网页，关键的JavaScript脚本请求可以设置为高优先级，这样服务器就会优先处理它，以确保网页能够更快地加载和运行起来。")])]),t._v(" "),_("h2",{attrs:{id:"_4、服务器推送"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、服务器推送"}},[t._v("#")]),t._v(" 4、服务器推送")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("HTTP 1.0")]),t._v("：不存在服务器推送（Server Push）功能，客户端只能通过发送请求来获取资源，服务器只能被动地响应客户端的请求。")]),t._v(" "),_("p",[t._v("例如，客户端需要先知道网页上有哪些资源（如图片、CSS文件等），然后逐个发送请求去获取它们。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("HTTP 2.0")]),t._v("：引入了服务器推送功能，服务器可以在客户端没有发送请求的情况下，主动将一些相关资源推送给客户端。")]),t._v(" "),_("p",[t._v("例如，当客户端请求一个网页时，服务器除了发送网页本身外，还可以根据对网页内容的了解，主动推送可能会用到的图片、CSS文件等资源，这样可以进一步提高网页的加载速度，减少客户端后续单独发送请求获取这些资源的时间。")])])]),t._v(" "),_("h2",{attrs:{id:"_5、安全性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、安全性"}},[t._v("#")]),t._v(" 5、安全性")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("HTTP 1.0")]),t._v("：本身并不具备内在的安全性机制，通常需要借助其他协议（如SSL/TLS）来实现数据的加密传输和身份验证等安全功能。例如，要实现安全的网页浏览，需要在HTTP 1.0的基础上配置SSL/TLS，使其变成HTTPS 1.0。")]),t._v(" "),_("li",[_("strong",[t._v("HTTP 2.0")]),t._v("：同样自身不直接提供完整的安全功能，但在实际应用中，通常会与SSL/TLS结合使用，形成HTTPS 2.0，以确保数据的加密传输和身份验证等安全需求。并且，由于其性能上的优势，在结合SSL/TLS时，也能在一定程度上提高安全相关操作的效率。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);