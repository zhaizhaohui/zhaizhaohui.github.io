(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{312:function(t,_,v){"use strict";v.r(_);var r=v(8),a=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"http-1-1-有哪些改进"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-有哪些改进"}},[t._v("#")]),t._v(" HTTP 1.1 有哪些改进？")]),t._v(" "),_("p",[t._v("HTTP 1.1是在HTTP 1.0基础上进行了诸多改进的版本，以下是它的一些主要改进方面：")]),t._v(" "),_("h2",{attrs:{id:"_1、连接复用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、连接复用"}},[t._v("#")]),t._v(" 1、连接复用")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("改进描述")]),t._v("： HTTP 1.0中每个HTTP请求都需要建立一个新的TCP连接，这导致在请求多个资源（如网页中的多个图片、CSS文件、JavaScript文件等）时，频繁创建和关闭TCP连接带来较大开销。HTTP 1.1引入了持久连接（Persistent Connection）机制，允许在一次TCP连接上进行多次HTTP请求和响应的交互，即一个TCP连接可以在完成一次请求-响应后不立即关闭，而是保持打开状态，以便后续继续发送其他请求。")]),t._v(" "),_("li",[_("strong",[t._v("示例")]),t._v("： 比如一个网页包含多个图片资源，在HTTP 1.0下，每请求一张图片就需要建立一个新的TCP连接，而在HTTP 1.1下，浏览器可以通过同一个TCP连接依次请求这些图片，大大减少了建立和关闭连接的开销，提高了网络传输效率。")])]),t._v(" "),_("h2",{attrs:{id:"_2、请求方法扩展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、请求方法扩展"}},[t._v("#")]),t._v(" 2、请求方法扩展")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("改进描述")]),t._v("： HTTP 1.0主要定义了如GET、POST等几种基本的请求方法。HTTP 1.1在此基础上扩展了更多的请求方法，以满足不同的应用场景需求。")]),t._v(" "),_("li",[_("strong",[t._v("新增请求方法示例")]),t._v("：\n"),_("ul",[_("li",[_("strong",[t._v("PUT")]),t._v("：用于向服务器上传指定资源，通常用于更新服务器上已存在的资源内容。例如，将本地修改后的文件上传到服务器替换原来的版本。")]),t._v(" "),_("li",[_("strong",[t._v("DELETE")]),t._v("：用于请求服务器删除指定的资源。比如在一个文件管理系统中，通过DELETE方法请求服务器删除某个不需要的文件。")]),t._v(" "),_("li",[_("strong",[t._v("HEAD")]),t._v("：与GET方法类似，但服务器只返回响应头信息，而不返回实体内容。常用于获取资源的元信息，如查看一个网页文件的最后修改时间、内容长度等，而无需下载整个网页内容。")])])])]),t._v(" "),_("h2",{attrs:{id:"_3、缓存控制增强"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、缓存控制增强"}},[t._v("#")]),t._v(" 3、缓存控制增强")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("改进描述")]),t._v("： HTTP 1.0中主要通过Expires字段来控制缓存，它是基于绝对时间来确定缓存是否过期，存在与客户端时钟不一致等问题。HTTP 1.1引入了更为灵活和精确的Cache-Control头字段来控制缓存行为。")]),t._v(" "),_("li",[_("strong",[t._v("Cache-Control指令示例")]),t._v("：\n"),_("ul",[_("li",[_("strong",[t._v("max-age")]),t._v("：指定资源在缓存中可以保存的最长时间（以秒为单位）。例如，“Cache-Control: max-age=3600”表示资源在缓存中最多可保存一小时，在这一小时内，客户端再次请求该资源时，可以直接从缓存中获取，无需向服务器确认。")]),t._v(" "),_("li",[_("strong",[t._v("no-cache")]),t._v("：表示客户端在使用缓存之前必须先向服务器验证缓存的有效性。虽然叫“no-cache”，但并不是不缓存，而是强调需要先验证。")]),t._v(" "),_("li",[_("strong",[t._v("no-store")]),t._v("：明确指示不允许缓存该资源，任何情况下都要从服务器获取新鲜的资源。")])])])]),t._v(" "),_("h2",{attrs:{id:"四、带宽优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、带宽优化"}},[t._v("#")]),t._v(" 四、带宽优化")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("改进描述")]),t._v("： HTTP 1.1在请求和响应的头部信息传输方面进行了优化。它允许在请求头和响应头中包含更多的信息，以更好地描述请求和响应的情况，同时也对一些不必要的头部信息进行了精简，避免了一些冗余信息的传输，从而在一定程度上优化了带宽使用。")]),t._v(" "),_("li",[_("strong",[t._v("示例")]),t._v("： 比如在HTTP 1.0中，可能会频繁传输一些固定格式的、对传输效率影响不大的信息，在HTTP 1.1中可以根据具体情况进行调整，只传输真正必要的信息，减少了网络带宽的占用。")])]),t._v(" "),_("h2",{attrs:{id:"_5、状态码扩展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、状态码扩展"}},[t._v("#")]),t._v(" 5、状态码扩展")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("改进描述")]),t._v("： HTTP 1.0定义了一些基本的状态码来表示请求的结果，如200表示成功，404表示未找到资源等。HTTP 1.1对状态码进行了扩展，增加了更多的状态码来更细致地表示不同的请求处理结果。")]),t._v(" "),_("li",[_("strong",[t._v("新增状态码示例")]),t._v("：\n"),_("ul",[_("li",[_("strong",[t._v("100 Continue")]),t._v("：当客户端发送一个可能较大的请求（如上传一个大文件）时，先发送一个包含部分请求内容（如请求头）的初始请求，服务器收到后如果认为可以接受该请求，就会返回100 Continue状态码，告知客户端可以继续发送剩余的请求内容。")]),t._v(" "),_("li",[_("strong",[t._v("206 Partial Content")]),t._v("：用于当服务器响应的是部分资源内容时的情况。比如在下载一个大文件时，客户端可以请求下载文件的某一部分，服务器就会用206 Partial Content状态码返回所请求的部分内容。")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);